{"version":3,"sources":["../src/types.ts","../src/exact/facilitator/scheme.ts","../src/constants.ts","../src/exact/facilitator/register.ts","../src/exact/client/scheme.ts","../src/exact/client/register.ts","../src/exact/server/scheme.ts","../src/exact/server/register.ts","../src/signer.ts","../src/index.ts"],"sourcesContent":["/**\n * @module @erudite-intelligence/x402-tron-v2 - Types\n * @description Tron-specific payload and signer types for x402 V2\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose Define Tron payment payload structures and type guards\n */\n\n// =============================================================================\n// Payment Payload Types\n// =============================================================================\n\n/**\n * Tron exact payment payload for x402 V2.\n *\n * Unlike EVM (which uses EIP-3009/Permit2 signed authorizations) or SVM\n * (which uses partially-signed transactions), Tron uses a simpler model:\n * the client constructs and signs a TRC-20 transfer transaction, and the\n * facilitator verifies the transaction structure before broadcasting it.\n *\n * Flow:\n * 1. Client builds a TRC-20 transfer tx (from → payTo, amount)\n * 2. Client signs the tx with their private key\n * 3. Client sends the signed tx hex as the payload\n * 4. Facilitator decodes, verifies amounts/recipients, then broadcasts\n */\nexport interface ExactTronPayloadV2 {\n  /**\n   * The signed transaction as a JSON-serialized string.\n   * Produced by JSON.stringify(tronWeb.trx.sign(tx)).\n   * Contains: raw_data, raw_data_hex, txID, signature[], visible.\n   */\n  signedTransaction: string;\n\n  /**\n   * The sender's Tron address (base58 format).\n   * Used for verification that the signer matches the transfer `from`.\n   */\n  from: string;\n\n  /**\n   * Optional: transaction ID (txID) for pre-verification.\n   * TronWeb generates this deterministically from the transaction data.\n   */\n  txID?: string;\n}\n\n/**\n * Alternative payload: TRC-20 approve + facilitator-executed transfer.\n * The client approves the facilitator to spend their tokens, and the\n * facilitator executes the transferFrom on their behalf.\n *\n * This is more gas-efficient for the client (approve costs less energy\n * than transfer) and gives the facilitator control over execution timing.\n */\nexport interface ExactTronApprovePayloadV2 {\n  /**\n   * The approval method used\n   */\n  method: \"approve\";\n\n  /**\n   * The signed approval transaction in hex format.\n   * Approves the facilitator address to spend the exact payment amount.\n   */\n  signedApproval: string;\n\n  /**\n   * The sender's Tron address (base58 format).\n   */\n  from: string;\n\n  /**\n   * The nonce or unique identifier to prevent replay\n   */\n  nonce: string;\n}\n\n/**\n * Union type for all supported Tron exact payloads\n */\nexport type ExactTronPayload = ExactTronPayloadV2 | ExactTronApprovePayloadV2;\n\n// =============================================================================\n// Type Guards\n// =============================================================================\n\n/**\n * Check if a payload is a direct signed transaction payload\n */\nexport function isSignedTransactionPayload(\n  payload: unknown,\n): payload is ExactTronPayloadV2 {\n  if (typeof payload !== \"object\" || payload === null) return false;\n  const p = payload as Record<string, unknown>;\n  return (\n    typeof p.signedTransaction === \"string\" &&\n    typeof p.from === \"string\" &&\n    !(\"method\" in p)\n  );\n}\n\n/**\n * Check if a payload is an approve-based payload\n */\nexport function isApprovePayload(\n  payload: unknown,\n): payload is ExactTronApprovePayloadV2 {\n  if (typeof payload !== \"object\" || payload === null) return false;\n  const p = payload as Record<string, unknown>;\n  return p.method === \"approve\" && typeof p.signedApproval === \"string\";\n}\n\n// =============================================================================\n// Configuration Types\n// =============================================================================\n\n/**\n * Configuration for the Tron facilitator.\n *\n * NOTE: useWrapperContract and feeDelegation are RESERVED for future implementation.\n * They are NOT currently active. Setting them has no effect on payment routing.\n * When implemented, useWrapperContract will route payments through the EruditePay\n * wrapper contract for automated on-chain fee deduction. feeDelegation will have\n * the facilitator cover energy costs for senders.\n */\nexport interface TronFacilitatorConfig {\n  /**\n   * RESERVED / NOT YET IMPLEMENTED.\n   * When implemented: Use EruditePay wrapper contract for automated fee collection.\n   * Currently has NO effect — payments always go direct from client to payTo.\n   * @default false\n   */\n  useWrapperContract?: boolean;\n\n  /**\n   * Optional: Maximum energy fee (in SUN) the facilitator will pay.\n   * Transactions exceeding this limit will be rejected during verification.\n   * @default 100_000_000 (100 TRX)\n   */\n  maxEnergyFeeSun?: number;\n\n  /**\n   * RESERVED / NOT YET IMPLEMENTED.\n   * When implemented: Facilitator pays energy costs on behalf of sender.\n   * Currently has NO effect — sender must have sufficient energy/TRX.\n   * @default false\n   */\n  feeDelegation?: boolean;\n}\n\n/**\n * Result of a Tron transaction broadcast\n */\nexport interface TronBroadcastResult {\n  result: boolean;\n  txid: string;\n  code?: string;\n  message?: string;\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Facilitator Scheme\n * @description x402 V2 facilitator implementation for the Tron exact payment scheme.\n *   Verifies and settles TRC-20 payment transactions on the Tron network.\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose First x402 V2 facilitator for Tron - verify signed TRC-20 transfers and broadcast them\n *\n * CHANGELOG:\n * - 2026-02-13: Initial implementation. Supports signed TRC-20 transfer verification and settlement.\n */\n\nimport type {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport type { FacilitatorTronSigner } from \"../../signer\";\nimport type { ExactTronPayloadV2, TronFacilitatorConfig } from \"../../types\";\nimport { isSignedTransactionPayload } from \"../../types\";\n\n/**\n * Tron facilitator implementation for the Exact payment scheme.\n *\n * Verification flow:\n * 1. Decode the signed transaction\n * 2. Verify it's a TRC-20 transfer to the correct recipient\n * 3. Verify the transfer amount meets requirements\n * 4. Verify the token contract matches the required asset\n * 5. Verify the sender has sufficient token balance\n * 6. Verify the transaction hasn't expired\n *\n * Settlement flow:\n * 1. Re-verify the payment (verify() is called internally)\n * 2. Broadcast the signed transaction to the Tron network\n * 3. Wait for confirmation\n * 4. Return the transaction hash\n */\nexport class ExactTronScheme implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"tron:*\";\n  private readonly config: Required<TronFacilitatorConfig>;\n\n  /**\n   * Creates a new ExactTronScheme facilitator instance.\n   *\n   * @param signer - The Tron signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorTronSigner,\n    config?: TronFacilitatorConfig,\n  ) {\n    this.config = {\n      useWrapperContract: config?.useWrapperContract ?? false,\n      maxEnergyFeeSun: config?.maxEnergyFeeSun ?? 100_000_000, // 100 TRX — reserved for future use\n      feeDelegation: config?.feeDelegation ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   *\n   * Currently returns minimal metadata. energyDelegation and wrapperContract\n   * will be exposed here once those features are implemented.\n   *\n   * @param _network - The network identifier (currently unused)\n   * @returns Extra data for clients, or undefined if no extra data\n   */\n  getExtra(_network: string): Record<string, unknown> | undefined {\n    // Only advertise features that are actually implemented.\n    // useWrapperContract and feeDelegation are reserved for future use.\n    // When implemented, they will be exposed here.\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * @param _network - The network identifier (unused - Tron addresses are network-agnostic)\n   * @returns Array of facilitator Tron addresses (base58)\n   */\n  getSigners(_network: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a Tron payment payload.\n   *\n   * Security checks performed:\n   * - Scheme and network validation\n   * - Transaction format validation (must be a TRC-20 transfer)\n   * - Token contract matches required asset\n   * - Recipient matches payTo address\n   * - Amount meets or exceeds required amount\n   * - Sender has sufficient token balance\n   * - Transaction has not expired\n   * - Facilitator address is NOT the sender (prevent self-transfers)\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    // Step 1: Validate scheme and network\n    if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: \"\",\n      };\n    }\n\n    if (payload.accepted.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: \"\",\n      };\n    }\n\n    // Step 2: Validate payload type\n    const rawPayload = payload.payload;\n    if (!isSignedTransactionPayload(rawPayload)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_type\",\n        invalidMessage: \"Expected signed transaction payload with 'signedTransaction' and 'from' fields\",\n        payer: \"\",\n      };\n    }\n\n    const tronPayload = rawPayload as unknown as ExactTronPayloadV2;\n\n    // Step 3: Decode and validate the transaction\n    let decoded;\n    try {\n      decoded = await this.signer.decodeTransaction(\n        tronPayload.signedTransaction,\n        requirements.network,\n      );\n    } catch (error) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_decode_failed\",\n        invalidMessage: error instanceof Error ? error.message : \"Failed to decode transaction\",\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 4: Verify it's a TRC-20 transfer (function selector a9059cbb)\n    if (decoded.contractType !== \"TriggerSmartContract\") {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_not_smart_contract\",\n        invalidMessage: `Expected TriggerSmartContract, got ${decoded.contractType}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    if (decoded.functionSelector !== \"a9059cbb\") {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_not_transfer\",\n        invalidMessage: `Expected transfer(address,uint256) selector a9059cbb, got ${decoded.functionSelector}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 5: Verify the token contract matches the required asset\n    if (decoded.contractAddress !== requirements.asset) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_asset_mismatch\",\n        invalidMessage: `Expected asset ${requirements.asset}, transaction targets ${decoded.contractAddress}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 6: Verify the recipient matches payTo\n    if (decoded.parameters.to !== requirements.payTo) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_recipient_mismatch\",\n        invalidMessage: `Expected recipient ${requirements.payTo}, transaction sends to ${decoded.parameters.to}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 7: Verify the amount meets requirements\n    const txAmount = BigInt(decoded.parameters.amount || \"0\");\n    const requiredAmount = BigInt(requirements.amount);\n\n    if (txAmount < requiredAmount) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_amount_insufficient\",\n        invalidMessage: `Required ${requiredAmount.toString()}, transaction sends ${txAmount.toString()}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 8: Verify the sender matches the claimed 'from' address\n    if (decoded.ownerAddress !== tronPayload.from) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_sender_mismatch\",\n        invalidMessage: \"Transaction owner does not match claimed sender\",\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 9: SECURITY - Verify facilitator is NOT the sender (prevent self-transfers)\n    const facilitatorAddresses = this.signer.getAddresses();\n    if (facilitatorAddresses.includes(decoded.ownerAddress)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_facilitator_is_sender\",\n        invalidMessage: \"Facilitator address cannot be the payment sender\",\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 10: Verify transaction has not expired\n    const now = Date.now();\n    if (decoded.expiration && decoded.expiration < now) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_expired\",\n        invalidMessage: `Transaction expired at ${new Date(decoded.expiration).toISOString()}`,\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 11: Verify sender has sufficient token balance\n    try {\n      const balance = await this.signer.getTokenBalance(\n        requirements.asset,\n        decoded.ownerAddress,\n        requirements.network,\n      );\n      const balanceBigInt = BigInt(balance);\n\n      if (balanceBigInt < requiredAmount) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_tron_payload_insufficient_balance\",\n          invalidMessage: `Sender balance ${balance} < required ${requirements.amount}`,\n          payer: tronPayload.from,\n        };\n      }\n    } catch (error) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_tron_payload_balance_check_failed\",\n        invalidMessage: error instanceof Error ? error.message : \"Balance check failed\",\n        payer: tronPayload.from,\n      };\n    }\n\n    // Step 12: Estimate energy cost and reject if too expensive\n    // Protects the facilitator from broadcasting extremely expensive txs\n    try {\n      const estimatedEnergy = await this.signer.estimateEnergy(\n        requirements.asset,\n        decoded.ownerAddress,\n        decoded.parameters.to || requirements.payTo,\n        requirements.amount,\n        requirements.network,\n      );\n\n      // Convert energy to SUN cost (energy price varies, use conservative 420 SUN/energy)\n      const estimatedFeeSun = estimatedEnergy * 420;\n      if (estimatedFeeSun > this.config.maxEnergyFeeSun) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_tron_payload_energy_too_expensive\",\n          invalidMessage: `Estimated energy cost ${estimatedFeeSun} SUN exceeds max ${this.config.maxEnergyFeeSun} SUN`,\n          payer: tronPayload.from,\n        };\n      }\n    } catch {\n      // Energy estimation is best-effort — don't reject if the RPC fails.\n      // The transaction may still succeed; confirmTransaction will catch failures.\n    }\n\n    // All checks passed\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer: tronPayload.from,\n    };\n  }\n\n  /**\n   * Settles a payment by broadcasting the signed transaction to the Tron network.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response with transaction hash\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    // First verify the payment\n    const verification = await this.verify(payload, requirements);\n    if (!verification.isValid) {\n      return {\n        success: false,\n        network: payload.accepted.network,\n        transaction: \"\",\n        errorReason: verification.invalidReason ?? \"verification_failed\",\n        errorMessage: verification.invalidMessage,\n        payer: verification.payer || \"\",\n      };\n    }\n\n    const tronPayload = payload.payload as unknown as ExactTronPayloadV2;\n\n    try {\n      // Second-layer verification: re-decode (which re-verifies signature)\n      // before broadcasting. Belt-and-suspenders against verify→settle race.\n      await this.signer.decodeTransaction(\n        tronPayload.signedTransaction,\n        requirements.network,\n      );\n\n      // Broadcast the signed transaction\n      // NOTE ON REPLAY PROTECTION: Tron nodes reject duplicate transactions\n      // (DUP_TRANSACTION_ERROR). An attacker attempting to reuse a previously\n      // settled transaction will fail at broadcast. Additionally, Tron\n      // transactions contain ref_block_bytes and ref_block_hash which bind\n      // them to a specific block range (~60 seconds), providing natural\n      // expiration. Combined with our expiration check in verify(), replay\n      // attacks are mitigated at the network layer.\n      //\n      // For additional safety, the x402 facilitator server (x402Facilitator\n      // class) should maintain a settled txID set to reject duplicates at\n      // the application layer before hitting the network.\n      const txID = await this.signer.broadcastTransaction(\n        tronPayload.signedTransaction,\n        requirements.network,\n      );\n\n      // Wait for confirmation\n      await this.signer.confirmTransaction(txID, requirements.network);\n\n      return {\n        success: true,\n        transaction: txID,\n        network: payload.accepted.network,\n        payer: verification.payer,\n      };\n    } catch (error) {\n      console.error(\"[x402-tron] Settlement failed:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_broadcast_failed\",\n        errorMessage: error instanceof Error ? error.message : \"Unknown broadcast error\",\n        transaction: \"\",\n        network: payload.accepted.network,\n        payer: verification.payer || \"\",\n      };\n    }\n  }\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Constants\n * @description Tron network constants for x402 V2 plugin\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose Define CAIP-2 identifiers, asset addresses, and network configuration for Tron\n */\n\n// =============================================================================\n// CAIP-2 Network Identifiers\n// Format: tron:<genesis_block_hash_prefix>\n// Reference: https://docs.offblocks.xyz/developer-guides/api-integration/blockchain-identifiers\n// =============================================================================\n\n/** Tron Mainnet CAIP-2 identifier */\nexport const TRON_MAINNET = \"tron:27Lqcw\" as const;\n\n/** Tron Shasta Testnet CAIP-2 identifier */\nexport const TRON_SHASTA = \"tron:4oPwXB\" as const;\n\n/** Tron Nile Testnet CAIP-2 identifier */\nexport const TRON_NILE = \"tron:6FhfKq\" as const;\n\n/** CAIP-2 family pattern for Tron networks */\nexport const TRON_CAIP_FAMILY = \"tron:*\" as const;\n\n/** All supported Tron networks for V2 registration */\nexport const TRON_NETWORKS = [TRON_MAINNET, TRON_SHASTA, TRON_NILE] as const;\n\n/** All supported Tron networks for V1 backwards compatibility */\nexport const TRON_V1_NETWORKS = [TRON_MAINNET] as const;\n\n// =============================================================================\n// RPC Endpoints\n// =============================================================================\n\n/** Default RPC endpoints per CAIP-2 network identifier */\nexport const TRON_RPC_URLS: Record<string, string> = {\n  [TRON_MAINNET]: \"https://api.trongrid.io\",\n  [TRON_SHASTA]: \"https://api.shasta.trongrid.io\",\n  [TRON_NILE]: \"https://nile.trongrid.io\",\n};\n\n// =============================================================================\n// Token Addresses (Base58)\n// =============================================================================\n\n/** USDT TRC-20 contract addresses by CAIP-2 network */\nexport const USDT_ADDRESSES: Record<string, string> = {\n  [TRON_MAINNET]: \"TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\",\n  [TRON_SHASTA]: \"TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs\", // Shasta USDT\n  [TRON_NILE]: \"TXLAQ63Xg1NAzckPwKHvzw7CSEmLMEqcdj\",   // Nile USDT\n};\n\n/** USDC TRC-20 contract addresses by CAIP-2 network */\nexport const USDC_ADDRESSES: Record<string, string> = {\n  [TRON_MAINNET]: \"TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8\",\n};\n\n/** USDT decimals (6) - same across all TRC-20 USDT deployments */\nexport const USDT_DECIMALS = 6;\n\n/** USDC decimals (6) */\nexport const USDC_DECIMALS = 6;\n\n// =============================================================================\n// EruditePay Wrapper Contract\n// The hands-free x402 wrapper contract deployed on Tron mainnet.\n// Collects 0.25% facilitator fee automatically on-chain.\n// =============================================================================\n\n/** EruditePay wrapper contract address on Tron mainnet */\nexport const ERUDITEPAY_WRAPPER_CONTRACT = \"THGkLBrLY1G5VovZjjK1jP9upyxRdMNL3b\";\n\n/** EruditePay facilitator fee: 0.25% (25 basis points) */\nexport const ERUDITEPAY_FEE_BPS = 25;\n\n// =============================================================================\n// TRC-20 ABI (minimal for transfer operations)\n// =============================================================================\n\n/** Minimal TRC-20 ABI for transfer and balance operations */\nexport const TRC20_ABI = [\n  {\n    constant: false,\n    inputs: [\n      { name: \"_to\", type: \"address\" },\n      { name: \"_value\", type: \"uint256\" },\n    ],\n    name: \"transfer\",\n    outputs: [{ name: \"\", type: \"bool\" }],\n    type: \"Function\",\n  },\n  {\n    constant: true,\n    inputs: [{ name: \"_owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"balance\", type: \"uint256\" }],\n    type: \"Function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      { name: \"_owner\", type: \"address\" },\n      { name: \"_spender\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ name: \"remaining\", type: \"uint256\" }],\n    type: \"Function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      { name: \"_spender\", type: \"address\" },\n      { name: \"_value\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ name: \"\", type: \"bool\" }],\n    type: \"Function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ name: \"\", type: \"uint8\" }],\n    type: \"Function\",\n  },\n] as const;\n\n// =============================================================================\n// Energy/Bandwidth Defaults\n// =============================================================================\n\n/**\n * Estimated energy cost for a TRC-20 transfer.\n * Used for pre-flight checks. Actual cost may vary.\n */\nexport const ESTIMATED_TRC20_TRANSFER_ENERGY = 65_000;\n\n/**\n * Estimated bandwidth cost for a TRC-20 transfer (in bytes).\n * Used for pre-flight checks.\n */\nexport const ESTIMATED_TRC20_TRANSFER_BANDWIDTH = 350;\n\n/**\n * Maximum acceptable energy fee for a facilitator-paid transaction (in SUN).\n * 100 TRX = 100_000_000 SUN. Prevents runaway costs.\n */\nexport const MAX_ENERGY_FEE_SUN = 100_000_000;\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Facilitator Registration\n * @description Registration helper to add Tron support to any x402 V2 facilitator\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose One-line registration of Tron exact scheme into x402Facilitator\n *\n * CHANGELOG:\n * - 2026-02-13: Initial implementation. Mirrors registerExactEvmScheme/registerExactSvmScheme patterns.\n */\n\nimport { x402Facilitator } from \"@x402/core/facilitator\";\nimport type { Network } from \"@x402/core/types\";\nimport type { FacilitatorTronSigner } from \"../../signer\";\nimport type { TronFacilitatorConfig } from \"../../types\";\nimport { ExactTronScheme } from \"./scheme\";\nimport { TRON_NETWORKS } from \"../../constants\";\n\n/**\n * Configuration options for registering Tron schemes to an x402Facilitator\n */\nexport interface TronFacilitatorRegistrationConfig {\n  /**\n   * The Tron signer for facilitator operations (verify and settle)\n   */\n  signer: FacilitatorTronSigner;\n\n  /**\n   * Networks to register (single network or array of networks).\n   * Defaults to all Tron networks (mainnet, Shasta, Nile).\n   *\n   * @example\n   * // Single network\n   * networks: \"tron:27Lqcw\"\n   *\n   * @example\n   * // Multiple networks\n   * networks: [\"tron:27Lqcw\", \"tron:4oPwXB\"]\n   *\n   * @default TRON_NETWORKS (all supported Tron networks)\n   */\n  networks?: Network | Network[];\n\n  /**\n   * Optional scheme-level configuration\n   */\n  config?: TronFacilitatorConfig;\n}\n\n/**\n * Registers Tron exact payment schemes to an x402Facilitator instance.\n *\n * This is the primary integration point for adding Tron support to any\n * x402 V2 facilitator. Call this alongside registerExactEvmScheme and\n * registerExactSvmScheme to build a multi-chain facilitator.\n *\n * @param facilitator - The x402Facilitator instance to register schemes to\n * @param config - Configuration for Tron facilitator registration\n * @returns The facilitator instance for chaining\n *\n * @example\n * ```typescript\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { registerExactEvmScheme } from \"@x402/evm/exact/facilitator/register\";\n * import { registerExactTronScheme } from \"@erudite-intelligence/x402-tron-v2/exact/facilitator/register\";\n * import { toFacilitatorTronSigner } from \"@erudite-intelligence/x402-tron-v2\";\n * import TronWeb from \"tronweb\";\n *\n * const facilitator = new x402Facilitator();\n *\n * // Register EVM chains (Base, Ethereum, etc.)\n * registerExactEvmScheme(facilitator, { signer: evmSigner, networks: \"eip155:8453\" });\n *\n * // Register Tron (USDT TRC-20)\n * const tronWeb = new TronWeb({ fullHost: \"https://api.trongrid.io\", privateKey: \"...\" });\n * const tronSigner = toFacilitatorTronSigner(tronWeb);\n * registerExactTronScheme(facilitator, { signer: tronSigner });\n *\n * // Facilitator now handles both Base USDC and Tron USDT!\n * ```\n */\nexport function registerExactTronScheme(\n  facilitator: x402Facilitator,\n  config: TronFacilitatorRegistrationConfig,\n): x402Facilitator {\n  const networks = config.networks\n    ? (Array.isArray(config.networks) ? config.networks : [config.networks])\n    : [...TRON_NETWORKS] as Network[];\n\n  // Register V2 scheme with specified networks\n  facilitator.register(\n    networks as Network[],\n    new ExactTronScheme(config.signer, config.config),\n  );\n\n  // Note: V1 backwards compatibility is not registered for Tron because\n  // Tron was never part of the x402 V1 spec. This is a V2-only chain.\n  // If V1 support is needed in the future, it can be added here.\n\n  return facilitator;\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Client Scheme\n * @description x402 V2 client implementation for creating Tron payment payloads.\n *   Builds and signs TRC-20 transfer transactions for x402 payments.\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose Enable x402 clients (AI agents, wallets) to create Tron payment payloads\n *\n * CHANGELOG:\n * - 2026-02-13: Initial implementation. Signed TRC-20 transfer payload creation.\n */\n\nimport type {\n  PaymentRequirements,\n  SchemeNetworkClient,\n  PaymentPayloadResult,\n} from \"@x402/core/types\";\nimport type { ClientTronSigner } from \"../../signer\";\n\n/**\n * Tron client implementation for the Exact payment scheme.\n *\n * Creates payment payloads by:\n * 1. Building a TRC-20 transfer transaction (to: payTo, amount: required amount)\n * 2. Signing it with the client's private key\n * 3. Returning the signed transaction as the payload\n *\n * The facilitator will then verify and broadcast this transaction.\n */\nexport class ExactTronScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactTronScheme client instance.\n   *\n   * @param signer - The Tron signer for client operations\n   */\n  constructor(private readonly signer: ClientTronSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme on Tron.\n   *\n   * Builds a TRC-20 transfer transaction targeting the merchant's (payTo) address\n   * for the required amount, signs it, and packages it as an x402 payload.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements from the resource server\n   * @returns Promise resolving to a payment payload result\n   *\n   * @example\n   * ```typescript\n   * const client = new ExactTronScheme(signer);\n   * const payload = await client.createPaymentPayload(2, {\n   *   scheme: \"exact\",\n   *   network: \"tron:27Lqcw\",\n   *   asset: \"TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\", // USDT\n   *   amount: \"1000000\", // 1 USDT\n   *   payTo: \"TRecipientAddress...\",\n   *   maxTimeoutSeconds: 300,\n   *   extra: {},\n   * });\n   * ```\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<PaymentPayloadResult> {\n    // Build the TRC-20 transfer transaction\n    const unsignedTx = await this.signer.buildTrc20Transfer(\n      paymentRequirements.asset,    // Token contract (e.g., USDT TRC-20)\n      paymentRequirements.payTo,    // Merchant address\n      paymentRequirements.amount,   // Amount in smallest unit\n    );\n\n    // Sign the transaction\n    const signedTx = await this.signer.signTransaction(unsignedTx);\n\n    // Package as x402 payload\n    return {\n      x402Version,\n      payload: {\n        signedTransaction: JSON.stringify(signedTx),\n        from: this.signer.address,\n        txID: (signedTx as Record<string, unknown>).txID as string | undefined,\n      },\n    };\n  }\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Client Registration\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n */\n\nimport { x402Client } from \"@x402/core/client\";\nimport type { Network } from \"@x402/core/types\";\nimport type { ClientTronSigner } from \"../../signer\";\nimport { ExactTronScheme } from \"./scheme\";\nimport { TRON_NETWORKS } from \"../../constants\";\n\n/**\n * Configuration options for registering Tron schemes to an x402Client\n */\nexport interface TronClientConfig {\n  signer: ClientTronSigner;\n  networks?: Network | Network[];\n}\n\n/**\n * Registers Tron exact payment schemes to an x402Client instance.\n *\n * @param client - The x402Client instance to register schemes to\n * @param config - Configuration for Tron client registration\n * @returns The client instance for chaining\n */\nexport function registerExactTronClientScheme(\n  client: x402Client,\n  config: TronClientConfig,\n): x402Client {\n  const networks = config.networks\n    ? (Array.isArray(config.networks) ? config.networks : [config.networks])\n    : ([...TRON_NETWORKS] as Network[]);\n\n  const scheme = new ExactTronScheme(config.signer);\n\n  // x402Client.register() takes a single Network per call (unlike x402Facilitator)\n  for (const network of networks) {\n    client.register(network, scheme);\n  }\n\n  return client;\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Server Scheme\n * @description x402 V2 server implementation for Tron. Handles price parsing\n *   and payment requirements enhancement for resource servers (merchants).\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose Enable resource servers to set prices in USDT and build Tron payment requirements\n *\n * CHANGELOG:\n * - 2026-02-13: Initial implementation. USDT default asset, custom money parser support.\n */\n\nimport type {\n  AssetAmount,\n  Network,\n  PaymentRequirements,\n  Price,\n  SchemeNetworkServer,\n  MoneyParser,\n} from \"@x402/core/types\";\nimport { USDT_ADDRESSES, USDT_DECIMALS } from \"../../constants\";\n\n/**\n * Tron server implementation for the Exact payment scheme.\n *\n * Converts user-friendly prices (e.g., \"$1.50\", 0.10) into the correct\n * token amount and asset format for Tron TRC-20 tokens.\n *\n * Default behavior:\n * - Treats numeric/string prices as USD amounts\n * - Converts to USDT TRC-20 with 6 decimal precision\n * - e.g., \"$1.50\" → { amount: \"1500000\", asset: \"TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\" }\n */\nexport class ExactTronScheme implements SchemeNetworkServer {\n  readonly scheme = \"exact\";\n  private moneyParsers: MoneyParser[] = [];\n\n  /**\n   * Register a custom money parser in the parser chain.\n   * Multiple parsers can be registered - they are tried in registration order.\n   * If a parser returns null, the next parser is tried.\n   * The default USDT parser is always the final fallback.\n   *\n   * @param parser - Custom function to convert amount to AssetAmount (or null to skip)\n   * @returns The service instance for chaining\n   */\n  registerMoneyParser(parser: MoneyParser): ExactTronScheme {\n    this.moneyParsers.push(parser);\n    return this;\n  }\n\n  /**\n   * Parses a price into an asset amount for Tron.\n   *\n   * Supports three input formats:\n   * 1. AssetAmount: { amount: \"1000000\", asset: \"TR7NHqje...\" } → pass through\n   * 2. String: \"$1.50\" or \"1.50\" → convert to USDT smallest unit\n   * 3. Number: 1.50 → convert to USDT smallest unit\n   *\n   * @param price - The price to parse\n   * @param network - The Tron network CAIP-2 identifier\n   * @returns Promise resolving to the parsed asset amount\n   */\n  async parsePrice(price: Price, network: Network): Promise<AssetAmount> {\n    // If already an AssetAmount, return it directly\n    if (typeof price === \"object\" && price !== null && \"amount\" in price) {\n      if (!price.asset) {\n        throw new Error(`Asset address must be specified for AssetAmount on network ${network}`);\n      }\n      return {\n        amount: price.amount,\n        asset: price.asset,\n        extra: price.extra || {},\n      };\n    }\n\n    // Parse Money to decimal number\n    const amount = this.parseMoneyToDecimal(price);\n\n    // Try each custom money parser in order\n    for (const parser of this.moneyParsers) {\n      const result = await parser(amount, network);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // Default: convert to USDT\n    return this.defaultMoneyConversion(amount, network);\n  }\n\n  /**\n   * Build payment requirements for this scheme/network combination.\n   *\n   * For Tron, this adds Tron-specific metadata to the requirements:\n   * - energyDelegation info from facilitator extra data\n   * - wrapper contract address if applicable\n   *\n   * @param paymentRequirements - Base payment requirements with amount/asset set\n   * @param supportedKind - The supported kind from facilitator's /supported endpoint\n   * @param extensionKeys - Extensions supported by the facilitator\n   * @returns Enhanced payment requirements\n   */\n  enhancePaymentRequirements(\n    paymentRequirements: PaymentRequirements,\n    supportedKind: {\n      x402Version: number;\n      scheme: string;\n      network: Network;\n      extra?: Record<string, unknown>;\n    },\n    extensionKeys: string[],\n  ): Promise<PaymentRequirements> {\n    void extensionKeys;\n\n    const extraData: Record<string, unknown> = {\n      ...paymentRequirements.extra,\n    };\n\n    // Pass through any facilitator-provided extra metadata\n    // Currently no Tron-specific extras are implemented.\n    // When useWrapperContract and feeDelegation go live, their\n    // metadata will be forwarded here.\n    if (supportedKind.extra) {\n      for (const [key, val] of Object.entries(supportedKind.extra)) {\n        if (val !== undefined) {\n          extraData[key] = val;\n        }\n      }\n    }\n\n    return Promise.resolve({\n      ...paymentRequirements,\n      extra: extraData,\n    });\n  }\n\n  /**\n   * Parse Money (string | number) to a decimal number.\n   * Handles formats like \"$1.50\", \"1.50\", 1.50, etc.\n   */\n  private parseMoneyToDecimal(money: string | number): number {\n    if (typeof money === \"number\") {\n      return money;\n    }\n    const cleanMoney = money.replace(/^\\$/, \"\").trim();\n    const amount = parseFloat(cleanMoney);\n    if (isNaN(amount)) {\n      throw new Error(`Invalid money format: ${money}`);\n    }\n    return amount;\n  }\n\n  /**\n   * Default money conversion: USD amount → USDT TRC-20 smallest unit.\n   * USDT has 6 decimals, so $1.50 → 1500000.\n   */\n  private defaultMoneyConversion(amount: number, network: Network): AssetAmount {\n    const usdtAddress = USDT_ADDRESSES[network];\n    if (!usdtAddress) {\n      throw new Error(\n        `No default USDT address configured for network ${network}. ` +\n        `Provide an explicit AssetAmount or register a custom MoneyParser.`,\n      );\n    }\n\n    // Convert decimal amount to smallest unit (6 decimals for USDT)\n    const tokenAmount = Math.round(amount * 10 ** USDT_DECIMALS).toString();\n\n    return {\n      amount: tokenAmount,\n      asset: usdtAddress,\n      extra: {},\n    };\n  }\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Server Registration\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n */\n\nimport { x402ResourceServer } from \"@x402/core/server\";\nimport type { Network } from \"@x402/core/types\";\nimport { ExactTronScheme } from \"./scheme\";\nimport { TRON_NETWORKS } from \"../../constants\";\n\n/**\n * Configuration options for registering Tron schemes to an x402ResourceServer\n */\nexport interface TronServerConfig {\n  networks?: Network | Network[];\n}\n\n/**\n * Registers Tron exact payment schemes to an x402ResourceServer instance.\n *\n * @param server - The x402ResourceServer instance to register schemes to\n * @param config - Optional configuration for Tron server registration\n * @returns The server instance for chaining\n */\nexport function registerExactTronServerScheme(\n  server: x402ResourceServer,\n  config?: TronServerConfig,\n): x402ResourceServer {\n  const networks = config?.networks\n    ? (Array.isArray(config.networks) ? config.networks : [config.networks])\n    : ([...TRON_NETWORKS] as Network[]);\n\n  const scheme = new ExactTronScheme();\n\n  // x402ResourceServer.register() takes a single Network per call\n  for (const network of networks) {\n    server.register(network, scheme);\n  }\n\n  return server;\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2 - Signer\n * @description TronWeb signer abstraction for x402 V2 facilitator and client operations\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @purpose Provide a clean signer interface matching x402 V2 patterns (EVM/SVM parity)\n */\n\nimport { TRON_RPC_URLS, TRC20_ABI } from \"./constants\";\n\n// =============================================================================\n// Client Signer\n// =============================================================================\n\n/**\n * Client-side signer for creating and signing Tron transactions.\n * Wraps a TronWeb instance with a connected wallet.\n */\nexport type ClientTronSigner = {\n  /** The Tron address (base58) of the signer */\n  readonly address: string;\n\n  /**\n   * Sign a transaction object and return the signed transaction hex\n   * @param transaction - The unsigned Tron transaction object\n   * @returns Signed transaction object with signature\n   */\n  signTransaction(transaction: Record<string, unknown>): Promise<Record<string, unknown>>;\n\n  /**\n   * Build a TRC-20 transfer transaction (unsigned)\n   * @param contractAddress - TRC-20 token contract address\n   * @param to - Recipient address\n   * @param amount - Amount in smallest unit (e.g., 1000000 for 1 USDT)\n   * @returns Unsigned transaction object\n   */\n  buildTrc20Transfer(\n    contractAddress: string,\n    to: string,\n    amount: string,\n  ): Promise<Record<string, unknown>>;\n};\n\n// =============================================================================\n// Facilitator Signer\n// =============================================================================\n\n/**\n * Minimal facilitator signer interface for Tron operations.\n * Supports multiple addresses for load balancing.\n * All implementation details (TronWeb instances, key management) are hidden.\n *\n * Mirrors the FacilitatorSvmSigner and FacilitatorEvmSigner patterns\n * from the official x402 SDK for consistency.\n */\nexport type FacilitatorTronSigner = {\n  /**\n   * Get all addresses this facilitator can use for operations.\n   * Enables dynamic address selection for load balancing.\n   * @returns Array of base58 Tron addresses\n   */\n  getAddresses(): readonly string[];\n\n  /**\n   * Verify a signed transaction without broadcasting.\n   * Checks: valid signature, correct format, sender matches claimed address.\n   * @param signedTxHex - The signed transaction in hex\n   * @param network - CAIP-2 network identifier (e.g., \"tron:27Lqcw\")\n   * @returns Decoded transaction details for further verification\n   */\n  decodeTransaction(\n    signedTxHex: string,\n    network: string,\n  ): Promise<DecodedTronTransaction>;\n\n  /**\n   * Broadcast a signed transaction to the Tron network.\n   * @param signedTxHex - The signed transaction in hex\n   * @param network - CAIP-2 network identifier\n   * @returns Transaction hash (txID) on success\n   * @throws Error if broadcast fails\n   */\n  broadcastTransaction(\n    signedTxHex: string,\n    network: string,\n  ): Promise<string>;\n\n  /**\n   * Wait for transaction confirmation on the Tron network.\n   * Polls until the transaction is confirmed or timeout.\n   * @param txID - Transaction ID to confirm\n   * @param network - CAIP-2 network identifier\n   * @throws Error if confirmation fails or times out\n   */\n  confirmTransaction(txID: string, network: string): Promise<void>;\n\n  /**\n   * Get the TRC-20 token balance for an address.\n   * @param tokenAddress - TRC-20 contract address\n   * @param ownerAddress - Address to check balance for\n   * @param network - CAIP-2 network identifier\n   * @returns Balance in smallest unit (string)\n   */\n  getTokenBalance(\n    tokenAddress: string,\n    ownerAddress: string,\n    network: string,\n  ): Promise<string>;\n\n  /**\n   * Estimate the energy cost of a TRC-20 transfer.\n   * @param tokenAddress - TRC-20 contract address\n   * @param from - Sender address\n   * @param to - Recipient address\n   * @param amount - Transfer amount\n   * @param network - CAIP-2 network identifier\n   * @returns Estimated energy cost\n   */\n  estimateEnergy(\n    tokenAddress: string,\n    from: string,\n    to: string,\n    amount: string,\n    network: string,\n  ): Promise<number>;\n};\n\n// =============================================================================\n// Decoded Transaction\n// =============================================================================\n\n/**\n * Decoded Tron transaction details for verification\n */\nexport interface DecodedTronTransaction {\n  /** Transaction ID */\n  txID: string;\n  /** The contract type (e.g., \"TriggerSmartContract\") */\n  contractType: string;\n  /** The contract address being called */\n  contractAddress: string;\n  /** The function selector (first 4 bytes of keccak256 of function signature) */\n  functionSelector: string;\n  /** Decoded function parameters */\n  parameters: {\n    /** Recipient address (for transfer) */\n    to?: string;\n    /** Amount (for transfer) */\n    amount?: string;\n    /** Spender address (for approve) */\n    spender?: string;\n  };\n  /** The sender (owner) address */\n  ownerAddress: string;\n  /** Transaction expiration timestamp */\n  expiration: number;\n  /** Raw signed transaction object */\n  rawTransaction: Record<string, unknown>;\n}\n\n// =============================================================================\n// Factory Functions\n// =============================================================================\n\n/**\n * Create a FacilitatorTronSigner from a TronWeb instance.\n *\n * @param tronWeb - TronWeb instance with private key configured\n * @param options - Optional configuration\n * @returns FacilitatorTronSigner ready for x402 V2 operations\n *\n * @example\n * ```typescript\n * import TronWeb from \"tronweb\";\n * import { toFacilitatorTronSigner } from \"@erudite-intelligence/x402-tron-v2\";\n *\n * const tronWeb = new TronWeb({\n *   fullHost: \"https://api.trongrid.io\",\n *   privateKey: process.env.TRON_PRIVATE_KEY,\n * });\n *\n * const signer = toFacilitatorTronSigner(tronWeb);\n * ```\n */\nexport function toFacilitatorTronSigner(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tronWeb: any,\n  options?: { additionalRpcUrls?: Record<string, string> },\n): FacilitatorTronSigner {\n  const rpcUrls = { ...TRON_RPC_URLS, ...options?.additionalRpcUrls };\n\n  /**\n   * Get or create a TronWeb instance for a specific network.\n   * Reuses the provided instance for the matching network,\n   * creates new instances for other networks.\n   */\n  const getTronWebForNetwork = (network: string) => {\n    const rpcUrl = rpcUrls[network];\n    if (!rpcUrl) {\n      throw new Error(`No RPC URL configured for network: ${network}`);\n    }\n    // If the current TronWeb instance points to the same host, reuse it\n    if (tronWeb.fullNode?.host === rpcUrl || tronWeb.fullNode?.host === rpcUrl + \"/\") {\n      return tronWeb;\n    }\n    // Create a new instance for a different network\n    const TronWebClass = tronWeb.constructor;\n    return new TronWebClass({\n      fullHost: rpcUrl,\n      privateKey: tronWeb.defaultPrivateKey,\n    });\n  };\n\n  return {\n    getAddresses: () => {\n      return [tronWeb.defaultAddress?.base58 || tronWeb.address?.toBase58()];\n    },\n\n    decodeTransaction: async (signedTxHex: string, network: string) => {\n      const tw = getTronWebForNetwork(network);\n      let tx: Record<string, unknown>;\n\n      try {\n        tx = JSON.parse(signedTxHex);\n      } catch {\n        // If it's not JSON, try treating it as raw hex\n        // TronWeb transactions are typically JSON objects\n        throw new Error(\"Invalid transaction format: expected JSON-serialized Tron transaction\");\n      }\n\n      // =====================================================================\n      // CRITICAL: Verify the transaction signature BEFORE parsing anything.\n      // Without this, an attacker can forge a transaction JSON with a rich\n      // victim's address, pass all verification checks, get resource access,\n      // and the settle() broadcast would fail (bad signature) — but the\n      // damage (free service) is already done.\n      // =====================================================================\n\n      // Step 1: Verify signature array exists and is non-empty\n      const signature = tx.signature as string[] | undefined;\n      if (!signature || !Array.isArray(signature) || signature.length === 0) {\n        throw new Error(\"Invalid transaction: missing or empty signature array\");\n      }\n\n      // Step 2: Verify each signature is a valid hex string (65 bytes = 130 hex chars)\n      for (const sig of signature) {\n        if (typeof sig !== \"string\" || !/^[0-9a-fA-F]{130}$/.test(sig)) {\n          throw new Error(\"Invalid transaction: malformed signature\");\n        }\n      }\n\n      // Step 3: Recompute the txID from raw_data to prevent txID tampering\n      const rawDataHex = tx.raw_data_hex as string;\n      if (!rawDataHex || typeof rawDataHex !== \"string\") {\n        throw new Error(\"Invalid transaction: missing raw_data_hex\");\n      }\n\n      // Validate raw_data_hex is actually valid hex\n      if (!/^[0-9a-fA-F]+$/.test(rawDataHex)) {\n        throw new Error(\"Invalid transaction: raw_data_hex contains non-hex characters\");\n      }\n\n      const computedTxID = tw.utils.crypto.sha256(\n        Buffer.from(rawDataHex, \"hex\"),\n      );\n      if (computedTxID !== tx.txID) {\n        throw new Error(\n          \"Invalid transaction: txID does not match raw_data hash (possible tampering)\",\n        );\n      }\n\n      // Step 4: Verify the signature using TronWeb's public verification.\n      // ECRecover the signer address to confirm it matches the transaction owner.\n      // We use the raw transaction object (which includes raw_data + signature)\n      // and let TronWeb handle the recovery ID and signing format internally.\n      let recoveredBase58: string;\n      try {\n        // TronWeb.trx.verifyMessage or manual ECRecover from txID + signature.\n        // The most reliable approach: recompute expected address from signature\n        // using the transaction's own verification method.\n        const messageBytes = Buffer.from(computedTxID, \"hex\");\n\n        // Use Trx.ecRecover which handles Tron's signing format correctly\n        // including the recovery ID (v value) in the 65th byte of the signature.\n        const sigBytes = Buffer.from(signature[0], \"hex\");\n        const v = sigBytes[64]; // Recovery ID\n        const r = sigBytes.subarray(0, 32);\n        const s = sigBytes.subarray(32, 64);\n\n        // TronWeb uses secp256k1 recovery: recover pubkey from (r, s, v, hash)\n        const recoveredHex = tw.utils.crypto.ecRecover(messageBytes, {\n          r: r.toString(\"hex\"),\n          s: s.toString(\"hex\"),\n          v,\n        });\n        recoveredBase58 = tw.address.fromHex(recoveredHex);\n      } catch (sigError) {\n        throw new Error(\n          `Signature recovery failed: ${sigError instanceof Error ? sigError.message : \"unknown error\"}`,\n        );\n      }\n\n      const rawData = tx.raw_data as Record<string, unknown>;\n      if (!rawData || !rawData.contract) {\n        throw new Error(\"Invalid transaction: missing raw_data.contract\");\n      }\n\n      const contracts = rawData.contract as Array<Record<string, unknown>>;\n      if (!contracts || contracts.length === 0) {\n        throw new Error(\"Invalid transaction: empty contract array\");\n      }\n\n      const contract = contracts[0];\n      const contractType = contract.type as string;\n      const parameter = contract.parameter as Record<string, unknown>;\n      const value = parameter?.value as Record<string, unknown>;\n\n      // Handle TriggerSmartContract (TRC-20 transfers)\n      if (contractType === \"TriggerSmartContract\") {\n        const contractAddress = tw.address.fromHex(value.contract_address as string);\n        const ownerAddress = tw.address.fromHex(value.owner_address as string);\n\n        // Step 5: Verify the recovered signer matches the claimed owner\n        if (recoveredBase58 !== ownerAddress) {\n          throw new Error(\n            `Signature verification failed: recovered ${recoveredBase58} but owner_address is ${ownerAddress}`,\n          );\n        }\n\n        const data = value.data as string;\n\n        // Validate data field exists and has minimum length for function selector\n        if (!data || typeof data !== \"string\" || data.length < 8) {\n          throw new Error(\"Invalid transaction: missing or malformed data field\");\n        }\n\n        // =====================================================================\n        // CRITICAL: Verify raw_data consistency with raw_data_hex.\n        //\n        // raw_data_hex is protobuf-encoded and is what the signature covers.\n        // raw_data is a JSON representation that SHOULD match but is NOT\n        // cryptographically bound to the signature. An attacker can:\n        //   1. Create a real tx for 1 USDT, sign it properly\n        //   2. Keep raw_data_hex and signature (which encode 1 USDT)\n        //   3. Modify raw_data JSON to say 1,000,000 USDT\n        //   4. verify() reads amount from raw_data → passes\n        //   5. On-chain, raw_data_hex says 1 USDT → underpayment\n        //\n        // Defense: Verify that critical fields from raw_data (the ABI call\n        // data, contract address, owner address) appear in raw_data_hex.\n        // These fields are embedded in the protobuf encoding and must be\n        // present. If an attacker tampers with raw_data, the values won't\n        // appear in raw_data_hex.\n        // =====================================================================\n\n        // The ABI call data (contains function selector + recipient + amount)\n        // must appear in raw_data_hex since protobuf stores it as raw bytes.\n        const dataLower = data.toLowerCase();\n        const rawDataHexLower = rawDataHex.toLowerCase();\n\n        if (!rawDataHexLower.includes(dataLower)) {\n          throw new Error(\n            \"Transaction integrity check failed: ABI call data in raw_data \" +\n            \"does not match raw_data_hex (possible raw_data tampering)\",\n          );\n        }\n\n        // The contract address (hex, without 41 prefix) must appear in raw_data_hex\n        const contractAddrHex = (value.contract_address as string).toLowerCase();\n        if (!rawDataHexLower.includes(contractAddrHex)) {\n          throw new Error(\n            \"Transaction integrity check failed: contract_address in raw_data \" +\n            \"does not match raw_data_hex (possible raw_data tampering)\",\n          );\n        }\n\n        // The owner address (hex, without 41 prefix or with it) must appear\n        const ownerAddrHex = (value.owner_address as string).toLowerCase();\n        if (!rawDataHexLower.includes(ownerAddrHex)) {\n          throw new Error(\n            \"Transaction integrity check failed: owner_address in raw_data \" +\n            \"does not match raw_data_hex (possible raw_data tampering)\",\n          );\n        }\n\n        // Parse the function selector and parameters from the data field\n        const functionSelector = data.substring(0, 8);\n        const params: DecodedTronTransaction[\"parameters\"] = {};\n\n        // Validate data field is valid hex before parsing\n        if (!/^[0-9a-fA-F]+$/.test(data)) {\n          throw new Error(\"Invalid transaction: data field contains non-hex characters\");\n        }\n\n        // transfer(address,uint256) selector: a9059cbb\n        // Expected data layout: 8 (selector) + 64 (address padded) + 64 (uint256) = 136 chars\n        if (functionSelector === \"a9059cbb\") {\n          if (data.length < 136) {\n            throw new Error(\n              `Invalid transfer data: expected 136+ hex chars, got ${data.length}`,\n            );\n          }\n          // Validate address padding (bytes 4-15 should be zero in ABI encoding)\n          const addressPadding = data.substring(8, 32);\n          if (!/^0+$/.test(addressPadding)) {\n            throw new Error(\n              \"Invalid transfer data: non-zero padding in address parameter\",\n            );\n          }\n          const toHex = \"41\" + data.substring(32, 72);\n          params.to = tw.address.fromHex(toHex);\n          params.amount = BigInt(\"0x\" + data.substring(72, 136)).toString();\n        }\n        // approve(address,uint256) selector: 095ea7b3\n        else if (functionSelector === \"095ea7b3\") {\n          if (data.length < 136) {\n            throw new Error(\n              `Invalid approve data: expected 136+ hex chars, got ${data.length}`,\n            );\n          }\n          const addressPadding = data.substring(8, 32);\n          if (!/^0+$/.test(addressPadding)) {\n            throw new Error(\n              \"Invalid approve data: non-zero padding in address parameter\",\n            );\n          }\n          const spenderHex = \"41\" + data.substring(32, 72);\n          params.spender = tw.address.fromHex(spenderHex);\n          params.amount = BigInt(\"0x\" + data.substring(72, 136)).toString();\n        }\n\n        return {\n          txID: computedTxID, // Use the COMPUTED txID, not the claimed one\n          contractType,\n          contractAddress,\n          functionSelector,\n          parameters: params,\n          ownerAddress,\n          expiration: rawData.expiration as number,\n          rawTransaction: tx,\n        };\n      }\n\n      throw new Error(`Unsupported contract type: ${contractType}`);\n    },\n\n    broadcastTransaction: async (signedTxHex: string, network: string) => {\n      const tw = getTronWebForNetwork(network);\n      let signedTx: Record<string, unknown>;\n\n      try {\n        signedTx = JSON.parse(signedTxHex);\n      } catch {\n        throw new Error(\"Invalid transaction format for broadcast\");\n      }\n\n      const result = await tw.trx.sendRawTransaction(signedTx);\n\n      if (result.result === true || result.code === \"SUCCESS\") {\n        return result.txid || (signedTx.txID as string);\n      }\n\n      const errorMsg = result.message\n        ? Buffer.from(result.message, \"hex\").toString(\"utf8\")\n        : result.code || \"Unknown broadcast error\";\n      throw new Error(`Broadcast failed: ${errorMsg}`);\n    },\n\n    confirmTransaction: async (txID: string, network: string) => {\n      const tw = getTronWebForNetwork(network);\n      const maxAttempts = 30;\n      const pollInterval = 3000; // 3 seconds (Tron block time ~3s)\n\n      for (let attempt = 0; attempt < maxAttempts; attempt++) {\n        try {\n          const txInfo = await tw.trx.getTransactionInfo(txID);\n          if (txInfo && txInfo.id) {\n            // Transaction found in a block — check execution result.\n            // For TRC-20 calls, the receipt.result indicates whether the\n            // smart contract execution succeeded. Possible values:\n            //   SUCCESS, REVERT, OUT_OF_ENERGY, OUT_OF_TIME, OTHER_ERROR\n            //\n            // We ONLY accept SUCCESS. Any other result means the USDT\n            // transfer did not execute, even though the tx is on-chain.\n            const receiptResult = txInfo.receipt?.result;\n\n            if (receiptResult === \"SUCCESS\") {\n              return; // Smart contract execution confirmed successful\n            }\n\n            if (receiptResult) {\n              // Transaction is on-chain but execution FAILED.\n              // The USDT did NOT move. This is NOT a successful payment.\n              throw new Error(\n                `Transaction on-chain but execution failed: ${receiptResult}` +\n                (txInfo.resMessage ? ` — ${txInfo.resMessage}` : \"\"),\n              );\n            }\n\n            // If no receipt yet, the transaction might still be processing.\n            // For TriggerSmartContract txs, receipt should appear within\n            // the same block. If txInfo has the id but no receipt after\n            // multiple attempts, something is wrong.\n            if (attempt > 5 && !receiptResult) {\n              throw new Error(\n                \"Transaction found on-chain but missing execution receipt after multiple checks\",\n              );\n            }\n          }\n        } catch (e) {\n          // If this is our own thrown error (not a network error), rethrow\n          if (e instanceof Error && (\n            e.message.includes(\"execution failed\") ||\n            e.message.includes(\"missing execution receipt\")\n          )) {\n            throw e;\n          }\n          // Transaction not yet indexed, keep polling\n          if (attempt === maxAttempts - 1) throw e;\n        }\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n      }\n\n      throw new Error(`Transaction confirmation timeout after ${maxAttempts * pollInterval / 1000}s`);\n    },\n\n    getTokenBalance: async (\n      tokenAddress: string,\n      ownerAddress: string,\n      network: string,\n    ) => {\n      const tw = getTronWebForNetwork(network);\n      const contract = await tw.contract(TRC20_ABI, tokenAddress);\n      const balance = await contract.methods.balanceOf(ownerAddress).call();\n      return balance.toString();\n    },\n\n    estimateEnergy: async (\n      tokenAddress: string,\n      from: string,\n      to: string,\n      amount: string,\n      network: string,\n    ) => {\n      const tw = getTronWebForNetwork(network);\n      try {\n        const result = await tw.transactionBuilder.estimateEnergy(\n          tokenAddress,\n          \"transfer(address,uint256)\",\n          {},\n          [\n            { type: \"address\", value: to },\n            { type: \"uint256\", value: amount },\n          ],\n          from,\n        );\n        return result.energy_required || 65000;\n      } catch {\n        // Fallback to conservative estimate\n        return 65000;\n      }\n    },\n  };\n}\n\n/**\n * Create a ClientTronSigner from a TronWeb instance.\n *\n * @param tronWeb - TronWeb instance with private key configured\n * @returns ClientTronSigner for creating payment payloads\n *\n * @example\n * ```typescript\n * import TronWeb from \"tronweb\";\n * import { toClientTronSigner } from \"@erudite-intelligence/x402-tron-v2\";\n *\n * const tronWeb = new TronWeb({\n *   fullHost: \"https://api.trongrid.io\",\n *   privateKey: process.env.TRON_PRIVATE_KEY,\n * });\n *\n * const signer = toClientTronSigner(tronWeb);\n * ```\n */\nexport function toClientTronSigner(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tronWeb: any,\n): ClientTronSigner {\n  return {\n    address: tronWeb.defaultAddress?.base58 || tronWeb.address?.toBase58(),\n\n    signTransaction: async (transaction: Record<string, unknown>) => {\n      return await tronWeb.trx.sign(transaction);\n    },\n\n    buildTrc20Transfer: async (\n      contractAddress: string,\n      to: string,\n      amount: string,\n    ) => {\n      const functionSelector = \"transfer(address,uint256)\";\n      const parameter = [\n        { type: \"address\", value: to },\n        { type: \"uint256\", value: amount },\n      ];\n\n      const tx = await tronWeb.transactionBuilder.triggerSmartContract(\n        contractAddress,\n        functionSelector,\n        { feeLimit: 80_000_000 }, // 80 TRX max fee (typical USDT transfer ~30-50 TRX)\n        parameter,\n      );\n\n      return tx.transaction;\n    },\n  };\n}\n","/**\n * @module @erudite-intelligence/x402-tron-v2\n * @description x402 Payment Protocol V2 - Tron Network Plugin\n *\n * The first and only x402 V2 implementation for the TRON blockchain.\n * Enables USDT TRC-20 payments for AI agents, web services, and merchants\n * through the x402 payment protocol.\n *\n * @author Erudite Intelligence LLC (Vector)\n * @created 2026-02-13\n * @license MIT\n *\n * @example\n * ```typescript\n * // Facilitator setup (processing payments)\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { registerExactTronScheme, toFacilitatorTronSigner } from \"@erudite-intelligence/x402-tron-v2\";\n * import TronWeb from \"tronweb\";\n *\n * const tronWeb = new TronWeb({ fullHost: \"https://api.trongrid.io\", privateKey: \"...\" });\n * const facilitator = new x402Facilitator();\n * registerExactTronScheme(facilitator, {\n *   signer: toFacilitatorTronSigner(tronWeb),\n *   networks: \"tron:27Lqcw\", // Tron mainnet\n * });\n * ```\n */\n\n// =============================================================================\n// Exact Scheme Exports\n// =============================================================================\n\n// Facilitator (verify & settle)\nexport { ExactTronScheme as ExactTronFacilitatorScheme } from \"./exact/facilitator\";\nexport { registerExactTronScheme } from \"./exact/facilitator\";\nexport type { TronFacilitatorRegistrationConfig } from \"./exact/facilitator\";\n\n// Client (create payment payloads)\nexport { ExactTronScheme as ExactTronClientScheme } from \"./exact/client\";\nexport { registerExactTronClientScheme } from \"./exact/client\";\nexport type { TronClientConfig } from \"./exact/client\";\n\n// Server (resource server / merchant)\nexport { ExactTronScheme as ExactTronServerScheme } from \"./exact/server\";\nexport { registerExactTronServerScheme } from \"./exact/server\";\nexport type { TronServerConfig } from \"./exact/server\";\n\n// =============================================================================\n// Signer Exports\n// =============================================================================\n\nexport { toFacilitatorTronSigner, toClientTronSigner } from \"./signer\";\nexport type {\n  FacilitatorTronSigner,\n  ClientTronSigner,\n  DecodedTronTransaction,\n} from \"./signer\";\n\n// =============================================================================\n// Type Exports\n// =============================================================================\n\nexport type {\n  ExactTronPayloadV2,\n  ExactTronApprovePayloadV2,\n  ExactTronPayload,\n  TronFacilitatorConfig,\n  TronBroadcastResult,\n} from \"./types\";\nexport { isSignedTransactionPayload, isApprovePayload } from \"./types\";\n\n// =============================================================================\n// Constant Exports\n// =============================================================================\n\n// Import constants used locally in utility functions below\nimport { USDT_ADDRESSES as _USDT_ADDRESSES, USDT_DECIMALS as _USDT_DECIMALS } from \"./constants\";\n\nexport {\n  TRON_MAINNET,\n  TRON_SHASTA,\n  TRON_NILE,\n  TRON_CAIP_FAMILY,\n  TRON_NETWORKS,\n  TRON_RPC_URLS,\n  USDT_ADDRESSES,\n  USDC_ADDRESSES,\n  USDT_DECIMALS,\n  USDC_DECIMALS,\n  ERUDITEPAY_WRAPPER_CONTRACT,\n  ERUDITEPAY_FEE_BPS,\n  TRC20_ABI,\n} from \"./constants\";\n\n// =============================================================================\n// Utility Exports\n// =============================================================================\n\n/**\n * Helper to get the USDT address for a given Tron CAIP-2 network.\n * @param network - CAIP-2 network identifier (e.g., \"tron:27Lqcw\")\n * @returns USDT TRC-20 contract address or undefined\n */\nexport function getUsdtAddress(network: string): string | undefined {\n  return _USDT_ADDRESSES[network];\n}\n\n/**\n * Helper to convert a decimal USD amount to USDT smallest unit.\n * @param usdAmount - Amount in USD (e.g., 1.50)\n * @returns Amount in USDT smallest unit (e.g., \"1500000\")\n */\nexport function usdToUsdt(usdAmount: number): string {\n  return Math.round(usdAmount * 10 ** _USDT_DECIMALS).toString();\n}\n"],"mappings":";AA0FO,SAAS,2BACd,SAC+B;AAC/B,MAAI,OAAO,YAAY,YAAY,YAAY,KAAM,QAAO;AAC5D,QAAM,IAAI;AACV,SACE,OAAO,EAAE,sBAAsB,YAC/B,OAAO,EAAE,SAAS,YAClB,EAAE,YAAY;AAElB;AAKO,SAAS,iBACd,SACsC;AACtC,MAAI,OAAO,YAAY,YAAY,YAAY,KAAM,QAAO;AAC5D,QAAM,IAAI;AACV,SAAO,EAAE,WAAW,aAAa,OAAO,EAAE,mBAAmB;AAC/D;;;ACvEO,IAAM,kBAAN,MAA0D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/D,YACmB,QACjB,QACA;AAFiB;AAGjB,SAAK,SAAS;AAAA,MACZ,oBAAoB,QAAQ,sBAAsB;AAAA,MAClD,iBAAiB,QAAQ,mBAAmB;AAAA;AAAA,MAC5C,eAAe,QAAQ,iBAAiB;AAAA,IAC1C;AAAA,EACF;AAAA,EAnBS,SAAS;AAAA,EACT,aAAa;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BjB,SAAS,UAAuD;AAI9D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,UAA4B;AACrC,WAAO,CAAC,GAAG,KAAK,OAAO,aAAa,CAAC;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,MAAM,OACJ,SACA,cACyB;AAEzB,QAAI,QAAQ,SAAS,WAAW,WAAW,aAAa,WAAW,SAAS;AAC1E,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,OAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,YAAY,aAAa,SAAS;AACrD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,OAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,aAAa,QAAQ;AAC3B,QAAI,CAAC,2BAA2B,UAAU,GAAG;AAC3C,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,OAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,cAAc;AAGpB,QAAI;AACJ,QAAI;AACF,gBAAU,MAAM,KAAK,OAAO;AAAA,QAC1B,YAAY;AAAA,QACZ,aAAa;AAAA,MACf;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzD,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,QAAI,QAAQ,iBAAiB,wBAAwB;AACnD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,sCAAsC,QAAQ,YAAY;AAAA,QAC1E,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAEA,QAAI,QAAQ,qBAAqB,YAAY;AAC3C,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,6DAA6D,QAAQ,gBAAgB;AAAA,QACrG,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,QAAI,QAAQ,oBAAoB,aAAa,OAAO;AAClD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,kBAAkB,aAAa,KAAK,yBAAyB,QAAQ,eAAe;AAAA,QACpG,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,QAAI,QAAQ,WAAW,OAAO,aAAa,OAAO;AAChD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,sBAAsB,aAAa,KAAK,0BAA0B,QAAQ,WAAW,EAAE;AAAA,QACvG,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,UAAM,WAAW,OAAO,QAAQ,WAAW,UAAU,GAAG;AACxD,UAAM,iBAAiB,OAAO,aAAa,MAAM;AAEjD,QAAI,WAAW,gBAAgB;AAC7B,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,YAAY,eAAe,SAAS,CAAC,uBAAuB,SAAS,SAAS,CAAC;AAAA,QAC/F,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,QAAI,QAAQ,iBAAiB,YAAY,MAAM;AAC7C,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,UAAM,uBAAuB,KAAK,OAAO,aAAa;AACtD,QAAI,qBAAqB,SAAS,QAAQ,YAAY,GAAG;AACvD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,QAAQ,cAAc,QAAQ,aAAa,KAAK;AAClD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,0BAA0B,IAAI,KAAK,QAAQ,UAAU,EAAE,YAAY,CAAC;AAAA,QACpF,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAGA,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,OAAO;AAAA,QAChC,aAAa;AAAA,QACb,QAAQ;AAAA,QACR,aAAa;AAAA,MACf;AACA,YAAM,gBAAgB,OAAO,OAAO;AAEpC,UAAI,gBAAgB,gBAAgB;AAClC,eAAO;AAAA,UACL,SAAS;AAAA,UACT,eAAe;AAAA,UACf,gBAAgB,kBAAkB,OAAO,eAAe,aAAa,MAAM;AAAA,UAC3E,OAAO,YAAY;AAAA,QACrB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe;AAAA,QACf,gBAAgB,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzD,OAAO,YAAY;AAAA,MACrB;AAAA,IACF;AAIA,QAAI;AACF,YAAM,kBAAkB,MAAM,KAAK,OAAO;AAAA,QACxC,aAAa;AAAA,QACb,QAAQ;AAAA,QACR,QAAQ,WAAW,MAAM,aAAa;AAAA,QACtC,aAAa;AAAA,QACb,aAAa;AAAA,MACf;AAGA,YAAM,kBAAkB,kBAAkB;AAC1C,UAAI,kBAAkB,KAAK,OAAO,iBAAiB;AACjD,eAAO;AAAA,UACL,SAAS;AAAA,UACT,eAAe;AAAA,UACf,gBAAgB,yBAAyB,eAAe,oBAAoB,KAAK,OAAO,eAAe;AAAA,UACvG,OAAO,YAAY;AAAA,QACrB;AAAA,MACF;AAAA,IACF,QAAQ;AAAA,IAGR;AAGA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,eAAe;AAAA,MACf,OAAO,YAAY;AAAA,IACrB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,OACJ,SACA,cACyB;AAEzB,UAAM,eAAe,MAAM,KAAK,OAAO,SAAS,YAAY;AAC5D,QAAI,CAAC,aAAa,SAAS;AACzB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS,QAAQ,SAAS;AAAA,QAC1B,aAAa;AAAA,QACb,aAAa,aAAa,iBAAiB;AAAA,QAC3C,cAAc,aAAa;AAAA,QAC3B,OAAO,aAAa,SAAS;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,QAAQ;AAE5B,QAAI;AAGF,YAAM,KAAK,OAAO;AAAA,QAChB,YAAY;AAAA,QACZ,aAAa;AAAA,MACf;AAcA,YAAM,OAAO,MAAM,KAAK,OAAO;AAAA,QAC7B,YAAY;AAAA,QACZ,aAAa;AAAA,MACf;AAGA,YAAM,KAAK,OAAO,mBAAmB,MAAM,aAAa,OAAO;AAE/D,aAAO;AAAA,QACL,SAAS;AAAA,QACT,aAAa;AAAA,QACb,SAAS,QAAQ,SAAS;AAAA,QAC1B,OAAO,aAAa;AAAA,MACtB;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,kCAAkC,KAAK;AACrD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,aAAa;AAAA,QACb,cAAc,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACvD,aAAa;AAAA,QACb,SAAS,QAAQ,SAAS;AAAA,QAC1B,OAAO,aAAa,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AACF;;;ACnWO,IAAM,eAAe;AAGrB,IAAM,cAAc;AAGpB,IAAM,YAAY;AAGlB,IAAM,mBAAmB;AAGzB,IAAM,gBAAgB,CAAC,cAAc,aAAa,SAAS;AAU3D,IAAM,gBAAwC;AAAA,EACnD,CAAC,YAAY,GAAG;AAAA,EAChB,CAAC,WAAW,GAAG;AAAA,EACf,CAAC,SAAS,GAAG;AACf;AAOO,IAAM,iBAAyC;AAAA,EACpD,CAAC,YAAY,GAAG;AAAA,EAChB,CAAC,WAAW,GAAG;AAAA;AAAA,EACf,CAAC,SAAS,GAAG;AAAA;AACf;AAGO,IAAM,iBAAyC;AAAA,EACpD,CAAC,YAAY,GAAG;AAClB;AAGO,IAAM,gBAAgB;AAGtB,IAAM,gBAAgB;AAStB,IAAM,8BAA8B;AAGpC,IAAM,qBAAqB;AAO3B,IAAM,YAAY;AAAA,EACvB;AAAA,IACE,UAAU;AAAA,IACV,QAAQ;AAAA,MACN,EAAE,MAAM,OAAO,MAAM,UAAU;AAAA,MAC/B,EAAE,MAAM,UAAU,MAAM,UAAU;AAAA,IACpC;AAAA,IACA,MAAM;AAAA,IACN,SAAS,CAAC,EAAE,MAAM,IAAI,MAAM,OAAO,CAAC;AAAA,IACpC,MAAM;AAAA,EACR;AAAA,EACA;AAAA,IACE,UAAU;AAAA,IACV,QAAQ,CAAC,EAAE,MAAM,UAAU,MAAM,UAAU,CAAC;AAAA,IAC5C,MAAM;AAAA,IACN,SAAS,CAAC,EAAE,MAAM,WAAW,MAAM,UAAU,CAAC;AAAA,IAC9C,MAAM;AAAA,EACR;AAAA,EACA;AAAA,IACE,UAAU;AAAA,IACV,QAAQ;AAAA,MACN,EAAE,MAAM,UAAU,MAAM,UAAU;AAAA,MAClC,EAAE,MAAM,YAAY,MAAM,UAAU;AAAA,IACtC;AAAA,IACA,MAAM;AAAA,IACN,SAAS,CAAC,EAAE,MAAM,aAAa,MAAM,UAAU,CAAC;AAAA,IAChD,MAAM;AAAA,EACR;AAAA,EACA;AAAA,IACE,UAAU;AAAA,IACV,QAAQ;AAAA,MACN,EAAE,MAAM,YAAY,MAAM,UAAU;AAAA,MACpC,EAAE,MAAM,UAAU,MAAM,UAAU;AAAA,IACpC;AAAA,IACA,MAAM;AAAA,IACN,SAAS,CAAC,EAAE,MAAM,IAAI,MAAM,OAAO,CAAC;AAAA,IACpC,MAAM;AAAA,EACR;AAAA,EACA;AAAA,IACE,UAAU;AAAA,IACV,QAAQ,CAAC;AAAA,IACT,MAAM;AAAA,IACN,SAAS,CAAC,EAAE,MAAM,IAAI,MAAM,QAAQ,CAAC;AAAA,IACrC,MAAM;AAAA,EACR;AACF;;;AC9CO,SAAS,wBACd,aACA,QACiB;AACjB,QAAM,WAAW,OAAO,WACnB,MAAM,QAAQ,OAAO,QAAQ,IAAI,OAAO,WAAW,CAAC,OAAO,QAAQ,IACpE,CAAC,GAAG,aAAa;AAGrB,cAAY;AAAA,IACV;AAAA,IACA,IAAI,gBAAgB,OAAO,QAAQ,OAAO,MAAM;AAAA,EAClD;AAMA,SAAO;AACT;;;ACvEO,IAAMA,mBAAN,MAAqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ1D,YAA6B,QAA0B;AAA1B;AAAA,EAA2B;AAAA,EAP/C,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiClB,MAAM,qBACJ,aACA,qBAC+B;AAE/B,UAAM,aAAa,MAAM,KAAK,OAAO;AAAA,MACnC,oBAAoB;AAAA;AAAA,MACpB,oBAAoB;AAAA;AAAA,MACpB,oBAAoB;AAAA;AAAA,IACtB;AAGA,UAAM,WAAW,MAAM,KAAK,OAAO,gBAAgB,UAAU;AAG7D,WAAO;AAAA,MACL;AAAA,MACA,SAAS;AAAA,QACP,mBAAmB,KAAK,UAAU,QAAQ;AAAA,QAC1C,MAAM,KAAK,OAAO;AAAA,QAClB,MAAO,SAAqC;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AACF;;;AC5DO,SAAS,8BACd,QACA,QACY;AACZ,QAAM,WAAW,OAAO,WACnB,MAAM,QAAQ,OAAO,QAAQ,IAAI,OAAO,WAAW,CAAC,OAAO,QAAQ,IACnE,CAAC,GAAG,aAAa;AAEtB,QAAM,SAAS,IAAIC,iBAAgB,OAAO,MAAM;AAGhD,aAAW,WAAW,UAAU;AAC9B,WAAO,SAAS,SAAS,MAAM;AAAA,EACjC;AAEA,SAAO;AACT;;;ACVO,IAAMC,mBAAN,MAAqD;AAAA,EACjD,SAAS;AAAA,EACV,eAA8B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWvC,oBAAoB,QAAsC;AACxD,SAAK,aAAa,KAAK,MAAM;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,WAAW,OAAc,SAAwC;AAErE,QAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,OAAO;AACpE,UAAI,CAAC,MAAM,OAAO;AAChB,cAAM,IAAI,MAAM,8DAA8D,OAAO,EAAE;AAAA,MACzF;AACA,aAAO;AAAA,QACL,QAAQ,MAAM;AAAA,QACd,OAAO,MAAM;AAAA,QACb,OAAO,MAAM,SAAS,CAAC;AAAA,MACzB;AAAA,IACF;AAGA,UAAM,SAAS,KAAK,oBAAoB,KAAK;AAG7C,eAAW,UAAU,KAAK,cAAc;AACtC,YAAM,SAAS,MAAM,OAAO,QAAQ,OAAO;AAC3C,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AAAA,IACF;AAGA,WAAO,KAAK,uBAAuB,QAAQ,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,2BACE,qBACA,eAMA,eAC8B;AAC9B,SAAK;AAEL,UAAM,YAAqC;AAAA,MACzC,GAAG,oBAAoB;AAAA,IACzB;AAMA,QAAI,cAAc,OAAO;AACvB,iBAAW,CAAC,KAAK,GAAG,KAAK,OAAO,QAAQ,cAAc,KAAK,GAAG;AAC5D,YAAI,QAAQ,QAAW;AACrB,oBAAU,GAAG,IAAI;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAEA,WAAO,QAAQ,QAAQ;AAAA,MACrB,GAAG;AAAA,MACH,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,oBAAoB,OAAgC;AAC1D,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AACA,UAAM,aAAa,MAAM,QAAQ,OAAO,EAAE,EAAE,KAAK;AACjD,UAAM,SAAS,WAAW,UAAU;AACpC,QAAI,MAAM,MAAM,GAAG;AACjB,YAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAAA,IAClD;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,uBAAuB,QAAgB,SAA+B;AAC5E,UAAM,cAAc,eAAe,OAAO;AAC1C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,kDAAkD,OAAO;AAAA,MAE3D;AAAA,IACF;AAGA,UAAM,cAAc,KAAK,MAAM,SAAS,MAAM,aAAa,EAAE,SAAS;AAEtE,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AACF;;;ACtJO,SAAS,8BACd,QACA,QACoB;AACpB,QAAM,WAAW,QAAQ,WACpB,MAAM,QAAQ,OAAO,QAAQ,IAAI,OAAO,WAAW,CAAC,OAAO,QAAQ,IACnE,CAAC,GAAG,aAAa;AAEtB,QAAM,SAAS,IAAIC,iBAAgB;AAGnC,aAAW,WAAW,UAAU;AAC9B,WAAO,SAAS,SAAS,MAAM;AAAA,EACjC;AAEA,SAAO;AACT;;;AC+IO,SAAS,wBAEd,SACA,SACuB;AACvB,QAAM,UAAU,EAAE,GAAG,eAAe,GAAG,SAAS,kBAAkB;AAOlE,QAAM,uBAAuB,CAAC,YAAoB;AAChD,UAAM,SAAS,QAAQ,OAAO;AAC9B,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,sCAAsC,OAAO,EAAE;AAAA,IACjE;AAEA,QAAI,QAAQ,UAAU,SAAS,UAAU,QAAQ,UAAU,SAAS,SAAS,KAAK;AAChF,aAAO;AAAA,IACT;AAEA,UAAM,eAAe,QAAQ;AAC7B,WAAO,IAAI,aAAa;AAAA,MACtB,UAAU;AAAA,MACV,YAAY,QAAQ;AAAA,IACtB,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,cAAc,MAAM;AAClB,aAAO,CAAC,QAAQ,gBAAgB,UAAU,QAAQ,SAAS,SAAS,CAAC;AAAA,IACvE;AAAA,IAEA,mBAAmB,OAAO,aAAqB,YAAoB;AACjE,YAAM,KAAK,qBAAqB,OAAO;AACvC,UAAI;AAEJ,UAAI;AACF,aAAK,KAAK,MAAM,WAAW;AAAA,MAC7B,QAAQ;AAGN,cAAM,IAAI,MAAM,uEAAuE;AAAA,MACzF;AAWA,YAAM,YAAY,GAAG;AACrB,UAAI,CAAC,aAAa,CAAC,MAAM,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG;AACrE,cAAM,IAAI,MAAM,uDAAuD;AAAA,MACzE;AAGA,iBAAW,OAAO,WAAW;AAC3B,YAAI,OAAO,QAAQ,YAAY,CAAC,qBAAqB,KAAK,GAAG,GAAG;AAC9D,gBAAM,IAAI,MAAM,0CAA0C;AAAA,QAC5D;AAAA,MACF;AAGA,YAAM,aAAa,GAAG;AACtB,UAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AACjD,cAAM,IAAI,MAAM,2CAA2C;AAAA,MAC7D;AAGA,UAAI,CAAC,iBAAiB,KAAK,UAAU,GAAG;AACtC,cAAM,IAAI,MAAM,+DAA+D;AAAA,MACjF;AAEA,YAAM,eAAe,GAAG,MAAM,OAAO;AAAA,QACnC,OAAO,KAAK,YAAY,KAAK;AAAA,MAC/B;AACA,UAAI,iBAAiB,GAAG,MAAM;AAC5B,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAMA,UAAI;AACJ,UAAI;AAIF,cAAM,eAAe,OAAO,KAAK,cAAc,KAAK;AAIpD,cAAM,WAAW,OAAO,KAAK,UAAU,CAAC,GAAG,KAAK;AAChD,cAAM,IAAI,SAAS,EAAE;AACrB,cAAM,IAAI,SAAS,SAAS,GAAG,EAAE;AACjC,cAAM,IAAI,SAAS,SAAS,IAAI,EAAE;AAGlC,cAAM,eAAe,GAAG,MAAM,OAAO,UAAU,cAAc;AAAA,UAC3D,GAAG,EAAE,SAAS,KAAK;AAAA,UACnB,GAAG,EAAE,SAAS,KAAK;AAAA,UACnB;AAAA,QACF,CAAC;AACD,0BAAkB,GAAG,QAAQ,QAAQ,YAAY;AAAA,MACnD,SAAS,UAAU;AACjB,cAAM,IAAI;AAAA,UACR,8BAA8B,oBAAoB,QAAQ,SAAS,UAAU,eAAe;AAAA,QAC9F;AAAA,MACF;AAEA,YAAM,UAAU,GAAG;AACnB,UAAI,CAAC,WAAW,CAAC,QAAQ,UAAU;AACjC,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE;AAEA,YAAM,YAAY,QAAQ;AAC1B,UAAI,CAAC,aAAa,UAAU,WAAW,GAAG;AACxC,cAAM,IAAI,MAAM,2CAA2C;AAAA,MAC7D;AAEA,YAAM,WAAW,UAAU,CAAC;AAC5B,YAAM,eAAe,SAAS;AAC9B,YAAM,YAAY,SAAS;AAC3B,YAAM,QAAQ,WAAW;AAGzB,UAAI,iBAAiB,wBAAwB;AAC3C,cAAM,kBAAkB,GAAG,QAAQ,QAAQ,MAAM,gBAA0B;AAC3E,cAAM,eAAe,GAAG,QAAQ,QAAQ,MAAM,aAAuB;AAGrE,YAAI,oBAAoB,cAAc;AACpC,gBAAM,IAAI;AAAA,YACR,4CAA4C,eAAe,yBAAyB,YAAY;AAAA,UAClG;AAAA,QACF;AAEA,cAAM,OAAO,MAAM;AAGnB,YAAI,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,GAAG;AACxD,gBAAM,IAAI,MAAM,sDAAsD;AAAA,QACxE;AAuBA,cAAM,YAAY,KAAK,YAAY;AACnC,cAAM,kBAAkB,WAAW,YAAY;AAE/C,YAAI,CAAC,gBAAgB,SAAS,SAAS,GAAG;AACxC,gBAAM,IAAI;AAAA,YACR;AAAA,UAEF;AAAA,QACF;AAGA,cAAM,kBAAmB,MAAM,iBAA4B,YAAY;AACvE,YAAI,CAAC,gBAAgB,SAAS,eAAe,GAAG;AAC9C,gBAAM,IAAI;AAAA,YACR;AAAA,UAEF;AAAA,QACF;AAGA,cAAM,eAAgB,MAAM,cAAyB,YAAY;AACjE,YAAI,CAAC,gBAAgB,SAAS,YAAY,GAAG;AAC3C,gBAAM,IAAI;AAAA,YACR;AAAA,UAEF;AAAA,QACF;AAGA,cAAM,mBAAmB,KAAK,UAAU,GAAG,CAAC;AAC5C,cAAM,SAA+C,CAAC;AAGtD,YAAI,CAAC,iBAAiB,KAAK,IAAI,GAAG;AAChC,gBAAM,IAAI,MAAM,6DAA6D;AAAA,QAC/E;AAIA,YAAI,qBAAqB,YAAY;AACnC,cAAI,KAAK,SAAS,KAAK;AACrB,kBAAM,IAAI;AAAA,cACR,uDAAuD,KAAK,MAAM;AAAA,YACpE;AAAA,UACF;AAEA,gBAAM,iBAAiB,KAAK,UAAU,GAAG,EAAE;AAC3C,cAAI,CAAC,OAAO,KAAK,cAAc,GAAG;AAChC,kBAAM,IAAI;AAAA,cACR;AAAA,YACF;AAAA,UACF;AACA,gBAAM,QAAQ,OAAO,KAAK,UAAU,IAAI,EAAE;AAC1C,iBAAO,KAAK,GAAG,QAAQ,QAAQ,KAAK;AACpC,iBAAO,SAAS,OAAO,OAAO,KAAK,UAAU,IAAI,GAAG,CAAC,EAAE,SAAS;AAAA,QAClE,WAES,qBAAqB,YAAY;AACxC,cAAI,KAAK,SAAS,KAAK;AACrB,kBAAM,IAAI;AAAA,cACR,sDAAsD,KAAK,MAAM;AAAA,YACnE;AAAA,UACF;AACA,gBAAM,iBAAiB,KAAK,UAAU,GAAG,EAAE;AAC3C,cAAI,CAAC,OAAO,KAAK,cAAc,GAAG;AAChC,kBAAM,IAAI;AAAA,cACR;AAAA,YACF;AAAA,UACF;AACA,gBAAM,aAAa,OAAO,KAAK,UAAU,IAAI,EAAE;AAC/C,iBAAO,UAAU,GAAG,QAAQ,QAAQ,UAAU;AAC9C,iBAAO,SAAS,OAAO,OAAO,KAAK,UAAU,IAAI,GAAG,CAAC,EAAE,SAAS;AAAA,QAClE;AAEA,eAAO;AAAA,UACL,MAAM;AAAA;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,UACA,YAAY;AAAA,UACZ;AAAA,UACA,YAAY,QAAQ;AAAA,UACpB,gBAAgB;AAAA,QAClB;AAAA,MACF;AAEA,YAAM,IAAI,MAAM,8BAA8B,YAAY,EAAE;AAAA,IAC9D;AAAA,IAEA,sBAAsB,OAAO,aAAqB,YAAoB;AACpE,YAAM,KAAK,qBAAqB,OAAO;AACvC,UAAI;AAEJ,UAAI;AACF,mBAAW,KAAK,MAAM,WAAW;AAAA,MACnC,QAAQ;AACN,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,YAAM,SAAS,MAAM,GAAG,IAAI,mBAAmB,QAAQ;AAEvD,UAAI,OAAO,WAAW,QAAQ,OAAO,SAAS,WAAW;AACvD,eAAO,OAAO,QAAS,SAAS;AAAA,MAClC;AAEA,YAAM,WAAW,OAAO,UACpB,OAAO,KAAK,OAAO,SAAS,KAAK,EAAE,SAAS,MAAM,IAClD,OAAO,QAAQ;AACnB,YAAM,IAAI,MAAM,qBAAqB,QAAQ,EAAE;AAAA,IACjD;AAAA,IAEA,oBAAoB,OAAO,MAAc,YAAoB;AAC3D,YAAM,KAAK,qBAAqB,OAAO;AACvC,YAAM,cAAc;AACpB,YAAM,eAAe;AAErB,eAAS,UAAU,GAAG,UAAU,aAAa,WAAW;AACtD,YAAI;AACF,gBAAM,SAAS,MAAM,GAAG,IAAI,mBAAmB,IAAI;AACnD,cAAI,UAAU,OAAO,IAAI;AAQvB,kBAAM,gBAAgB,OAAO,SAAS;AAEtC,gBAAI,kBAAkB,WAAW;AAC/B;AAAA,YACF;AAEA,gBAAI,eAAe;AAGjB,oBAAM,IAAI;AAAA,gBACR,8CAA8C,aAAa,MAC1D,OAAO,aAAa,WAAM,OAAO,UAAU,KAAK;AAAA,cACnD;AAAA,YACF;AAMA,gBAAI,UAAU,KAAK,CAAC,eAAe;AACjC,oBAAM,IAAI;AAAA,gBACR;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF,SAAS,GAAG;AAEV,cAAI,aAAa,UACf,EAAE,QAAQ,SAAS,kBAAkB,KACrC,EAAE,QAAQ,SAAS,2BAA2B,IAC7C;AACD,kBAAM;AAAA,UACR;AAEA,cAAI,YAAY,cAAc,EAAG,OAAM;AAAA,QACzC;AACA,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,YAAY,CAAC;AAAA,MAClE;AAEA,YAAM,IAAI,MAAM,0CAA0C,cAAc,eAAe,GAAI,GAAG;AAAA,IAChG;AAAA,IAEA,iBAAiB,OACf,cACA,cACA,YACG;AACH,YAAM,KAAK,qBAAqB,OAAO;AACvC,YAAM,WAAW,MAAM,GAAG,SAAS,WAAW,YAAY;AAC1D,YAAM,UAAU,MAAM,SAAS,QAAQ,UAAU,YAAY,EAAE,KAAK;AACpE,aAAO,QAAQ,SAAS;AAAA,IAC1B;AAAA,IAEA,gBAAgB,OACd,cACA,MACA,IACA,QACA,YACG;AACH,YAAM,KAAK,qBAAqB,OAAO;AACvC,UAAI;AACF,cAAM,SAAS,MAAM,GAAG,mBAAmB;AAAA,UACzC;AAAA,UACA;AAAA,UACA,CAAC;AAAA,UACD;AAAA,YACE,EAAE,MAAM,WAAW,OAAO,GAAG;AAAA,YAC7B,EAAE,MAAM,WAAW,OAAO,OAAO;AAAA,UACnC;AAAA,UACA;AAAA,QACF;AACA,eAAO,OAAO,mBAAmB;AAAA,MACnC,QAAQ;AAEN,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;AAqBO,SAAS,mBAEd,SACkB;AAClB,SAAO;AAAA,IACL,SAAS,QAAQ,gBAAgB,UAAU,QAAQ,SAAS,SAAS;AAAA,IAErE,iBAAiB,OAAO,gBAAyC;AAC/D,aAAO,MAAM,QAAQ,IAAI,KAAK,WAAW;AAAA,IAC3C;AAAA,IAEA,oBAAoB,OAClB,iBACA,IACA,WACG;AACH,YAAM,mBAAmB;AACzB,YAAM,YAAY;AAAA,QAChB,EAAE,MAAM,WAAW,OAAO,GAAG;AAAA,QAC7B,EAAE,MAAM,WAAW,OAAO,OAAO;AAAA,MACnC;AAEA,YAAM,KAAK,MAAM,QAAQ,mBAAmB;AAAA,QAC1C;AAAA,QACA;AAAA,QACA,EAAE,UAAU,IAAW;AAAA;AAAA,QACvB;AAAA,MACF;AAEA,aAAO,GAAG;AAAA,IACZ;AAAA,EACF;AACF;;;ACjgBO,SAAS,eAAe,SAAqC;AAClE,SAAO,eAAgB,OAAO;AAChC;AAOO,SAAS,UAAU,WAA2B;AACnD,SAAO,KAAK,MAAM,YAAY,MAAM,aAAc,EAAE,SAAS;AAC/D;","names":["ExactTronScheme","ExactTronScheme","ExactTronScheme","ExactTronScheme"]}